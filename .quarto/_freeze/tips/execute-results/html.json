{
  "hash": "6e2bd86f5a97aaa3d964218cb49f23a2",
  "result": {
    "markdown": "# そのためメモ\n\n便利だが普段はあまりつかわないため忘れがちな点についてメモしておく．\n本テキストのどこかで扱う内容もメモする．\n\n\n## 正規表現（regular expression）\n\n- extended regular expressions (the default)\n- Perl-like regular expressions\n- literal regular expressions\n\nメタキャラクター\n- `. \\ | ( ) [ { ^ $ * + ?`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n\n```{.r .cell-code}\ngrep(\"j|k\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 11\n```\n:::\n\n```{.r .cell-code}\ngrep(\"[jk]\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 11\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"j|k\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"[jk]\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nsub(\"[jk]\",\"XXXX\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\"    \"b\"    \"c\"    \"d\"    \"e\"    \"f\"    \"g\"    \"h\"    \"i\"    \"XXXX\"\n[11] \"XXXX\" \"l\"    \"m\"    \"n\"    \"o\"    \"p\"    \"q\"    \"r\"    \"s\"    \"t\"   \n[21] \"u\"    \"v\"    \"w\"    \"x\"    \"y\"    \"z\"   \n```\n:::\n\n```{.r .cell-code}\ngsub(\"[jk]\",\"XXXX\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\"    \"b\"    \"c\"    \"d\"    \"e\"    \"f\"    \"g\"    \"h\"    \"i\"    \"XXXX\"\n[11] \"XXXX\" \"l\"    \"m\"    \"n\"    \"o\"    \"p\"    \"q\"    \"r\"    \"s\"    \"t\"   \n[21] \"u\"    \"v\"    \"w\"    \"x\"    \"y\"    \"z\"   \n```\n:::\n\n```{.r .cell-code}\nregexpr(\"[jk]\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -1 -1 -1 -1 -1 -1 -1 -1 -1  1  1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n[26] -1\nattr(,\"match.length\")\n [1] -1 -1 -1 -1 -1 -1 -1 -1 -1  1  1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n[26] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngregexpr(\"[jk]\", letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[2]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[3]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[4]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[5]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[6]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[7]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[8]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[9]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[10]]\n[1] 1\nattr(,\"match.length\")\n[1] 1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[11]]\n[1] 1\nattr(,\"match.length\")\n[1] 1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[12]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[13]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[14]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[15]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[16]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[17]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[18]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[19]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[20]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[21]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[22]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[23]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[24]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[25]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[26]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nstarwars$name[grepl(\"aa|[k]\", starwars$name)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Luke Skywalker\"        \"Biggs Darklighter\"     \"Anakin Skywalker\"     \n [4] \"Wilhuff Tarkin\"        \"Jek Tono Porkins\"      \"Bossk\"                \n [7] \"Ackbar\"                \"Wicket Systri Warrick\" \"Jar Jar Binks\"        \n[10] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Dooku\"                \n[13] \"Shaak Ti\"             \n```\n:::\n:::\n\n\n\n## any_of, all_of\n\n変数名をオブジェクトとして用いるときに便利．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_vars <- c(\"height\", \"mass\")\nstarwars |> select(select_vars) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(select_vars)\n\n  # Now:\n  data %>% select(all_of(select_vars))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 2\n   height  mass\n    <int> <dbl>\n 1    172    77\n 2    167    75\n 3     96    32\n 4    202   136\n 5    150    49\n 6    178   120\n 7    165    75\n 8     97    32\n 9    183    84\n10    182    77\n# ℹ 77 more rows\n```\n:::\n\n```{.r .cell-code}\nstarwars |> select(any_of(select_vars))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 2\n   height  mass\n    <int> <dbl>\n 1    172    77\n 2    167    75\n 3     96    32\n 4    202   136\n 5    150    49\n 6    178   120\n 7    165    75\n 8     97    32\n 9    183    84\n10    182    77\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n\n## map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nx <- 1:10\nsqrt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n:::\n\n```{.r .cell-code}\nmap(x, sqrt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1.414214\n\n[[3]]\n[1] 1.732051\n\n[[4]]\n[1] 2\n\n[[5]]\n[1] 2.236068\n\n[[6]]\n[1] 2.44949\n\n[[7]]\n[1] 2.645751\n\n[[8]]\n[1] 2.828427\n\n[[9]]\n[1] 3\n\n[[10]]\n[1] 3.162278\n```\n:::\n\n```{.r .cell-code}\nmap_vec(x, sqrt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n:::\n:::\n\n\nd <- d %>% mutate(gpa_std = (gpa_sum - mean(gpa_sum, na.rm = TRUE)) \n  / sd(gpa_sum, na.rm = TRUE))\n\n## 部分一致\n\n`data.frame`形式であれば`$`で変数名の部分一致が利用できるが，`tibble`形式ではできない．部分一致によってエラーが生じる可能性もあるので省略せずに入力するほうが良い．\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nstarwars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu…\n 3 R2-D2        96    32 <NA>       white, bl… red             33   none  mascu…\n 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n 8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu…\n 9 Biggs D…    183    84 black      light      brown           24   male  mascu…\n10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n# ℹ 77 more rows\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n:::\n\n```{.r .cell-code}\nstarwars$hei\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `hei`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nstarwars$ha\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `ha`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nstarwars_df <- as.data.frame(starwars) \nstarwars_df$hei\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 172 167  96 202 150 178 165  97 183 182 188 180 228 180 173 175 170 180  66\n[20] 170 183 200 190 177 175 180 150  NA  88 160 193 191 170 196 224 206 183 137\n[39] 112 183 163 175 180 178  94 122 163 188 198 196 171 184 188 264 188 196 185\n[58] 157 183 183 170 166 165 193 191 183 168 198 229 213 167  79  96 193 191 178\n[77] 216 234 188 178 206  NA  NA  NA  NA  NA 165\n```\n:::\n\n```{.r .cell-code}\nstarwars_df$ha\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"blond\"         NA              NA              \"none\"         \n [5] \"brown\"         \"brown, grey\"   \"brown\"         NA             \n [9] \"black\"         \"auburn, white\" \"blond\"         \"auburn, grey\" \n[13] \"brown\"         \"brown\"         NA              NA             \n[17] \"brown\"         \"brown\"         \"white\"         \"grey\"         \n[21] \"black\"         \"none\"          \"none\"          \"black\"        \n[25] \"none\"          \"none\"          \"auburn\"        \"brown\"        \n[29] \"brown\"         \"none\"          \"brown\"         \"none\"         \n[33] \"blond\"         \"none\"          \"none\"          \"none\"         \n[37] \"brown\"         \"black\"         \"none\"          \"black\"        \n[41] \"black\"         \"none\"          \"none\"          \"none\"         \n[45] \"none\"          \"none\"          \"none\"          \"none\"         \n[49] \"white\"         \"none\"          \"black\"         \"none\"         \n[53] \"none\"          \"none\"          \"none\"          \"none\"         \n[57] \"black\"         \"brown\"         \"brown\"         \"none\"         \n[61] \"black\"         \"black\"         \"brown\"         \"white\"        \n[65] \"black\"         \"black\"         \"blonde\"        \"none\"         \n[69] \"none\"          \"none\"          \"white\"         \"none\"         \n[73] \"none\"          \"none\"          \"none\"          \"none\"         \n[77] \"none\"          \"brown\"         \"brown\"         \"none\"         \n[81] \"none\"          \"black\"         \"brown\"         \"brown\"        \n[85] \"none\"          \"unknown\"       \"brown\"        \n```\n:::\n:::\n\n\n\n## 因子\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0,1,1,1,0)\ny <- factor(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 1 1 0\nLevels: 0 1\n```\n:::\n\n```{.r .cell-code}\nstr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 2 levels \"0\",\"1\": 1 2 2 2 1\n```\n:::\n\n```{.r .cell-code}\nattributes(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$levels\n[1] \"0\" \"1\"\n\n$class\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nlevels(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0\" \"1\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 2 2 1\n```\n:::\n\n```{.r .cell-code}\nas.numeric(as.character(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 1 1 0\n```\n:::\n:::\n\n\n\n## 集計データを個票データに変換する\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# クロス表\noccupationalStatus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      destination\norigin   1   2   3   4   5   6   7   8\n     1  50  19  26   8   7  11   6   2\n     2  16  40  34  18  11  20   8   3\n     3  12  35  65  66  35  88  23  21\n     4  11  20  58 110  40 183  64  32\n     5   2   8  12  23  25  46  28  12\n     6  12  28 102 162  90 554 230 177\n     7   0   6  19  40  21 158 143  71\n     8   0   3  14  32  15 126  91 106\n```\n:::\n\n```{.r .cell-code}\n# 集計データ\ndata.frame(occupationalStatus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   origin destination Freq\n1       1           1   50\n2       2           1   16\n3       3           1   12\n4       4           1   11\n5       5           1    2\n6       6           1   12\n7       7           1    0\n8       8           1    0\n9       1           2   19\n10      2           2   40\n11      3           2   35\n12      4           2   20\n13      5           2    8\n14      6           2   28\n15      7           2    6\n16      8           2    3\n17      1           3   26\n18      2           3   34\n19      3           3   65\n20      4           3   58\n21      5           3   12\n22      6           3  102\n23      7           3   19\n24      8           3   14\n25      1           4    8\n26      2           4   18\n27      3           4   66\n28      4           4  110\n29      5           4   23\n30      6           4  162\n31      7           4   40\n32      8           4   32\n33      1           5    7\n34      2           5   11\n35      3           5   35\n36      4           5   40\n37      5           5   25\n38      6           5   90\n39      7           5   21\n40      8           5   15\n41      1           6   11\n42      2           6   20\n43      3           6   88\n44      4           6  183\n45      5           6   46\n46      6           6  554\n47      7           6  158\n48      8           6  126\n49      1           7    6\n50      2           7    8\n51      3           7   23\n52      4           7   64\n53      5           7   28\n54      6           7  230\n55      7           7  143\n56      8           7   91\n57      1           8    2\n58      2           8    3\n59      3           8   21\n60      4           8   32\n61      5           8   12\n62      6           8  177\n63      7           8   71\n64      8           8  106\n```\n:::\n\n```{.r .cell-code}\n# 個票データ\ndf_occupationalStatus <- vcdExtra::expand.dft(data.frame(occupationalStatus), dreq = \"Freq\") |> \n  mutate(across(origin:destination, factor))\n# \ndf_occupationalStatus |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     origin      destination  \n 6      :1355   6      :1186  \n 4      : 518   7      : 593  \n 7      : 458   4      : 459  \n 8      : 387   8      : 424  \n 3      : 345   3      : 330  \n 5      : 156   5      : 244  \n (Other): 279   (Other): 262  \n```\n:::\n:::\n\n\n\n\n## 関数の中身を確認する\n\n`mean()`関数がどのようにして作成されているのかを確認したい場合，`mean`のように`()`をとって入力すればよい．しかし，`UseMethod(\"mean\")`のように関数が表示され，中身を確認できない場合もある．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x12eafe8e8>\n<environment: namespace:base>\n```\n:::\n:::\n\n\nこのような場合は，`methods()`関数を用いるとよい\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] mean,ANY-method          mean,Matrix-method       mean,sparseMatrix-method\n [4] mean,sparseVector-method mean.Date*               mean.default*           \n [7] mean.difftime*           mean.POSIXct*            mean.POSIXlt*           \n[10] mean.quosure*            mean.vctrs_vctr*         mean.yearmon*           \n[13] mean.yearqtr*            mean.zoo*               \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n様々な結果が示されるがここでは，2めの要素にある`mean.default*`を確認しよう．`*`をとって`mean.default`と入力するだけでよい．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean.default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, trim = 0, na.rm = FALSE, ...) \n{\n    if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {\n        warning(\"argument is not numeric or logical: returning NA\")\n        return(NA_real_)\n    }\n    if (isTRUE(na.rm)) \n        x <- x[!is.na(x)]\n    if (!is.numeric(trim) || length(trim) != 1L) \n        stop(\"'trim' must be numeric of length one\")\n    n <- length(x)\n    if (trim > 0 && n) {\n        if (is.complex(x)) \n            stop(\"trimmed means are not defined for complex data\")\n        if (anyNA(x)) \n            return(NA_real_)\n        if (trim >= 0.5) \n            return(stats::median(x, na.rm = FALSE))\n        lo <- floor(n * trim) + 1\n        hi <- n + 1 - lo\n        x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]\n    }\n    .Internal(mean(x))\n}\n<bytecode: 0x119711518>\n<environment: namespace:base>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngetAnywhere(mean.default)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA single object matching 'mean.default' was found\nIt was found in the following places\n  package:base\n  registered S3 method for mean from namespace base\n  namespace:base\nwith value\n\nfunction (x, trim = 0, na.rm = FALSE, ...) \n{\n    if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {\n        warning(\"argument is not numeric or logical: returning NA\")\n        return(NA_real_)\n    }\n    if (isTRUE(na.rm)) \n        x <- x[!is.na(x)]\n    if (!is.numeric(trim) || length(trim) != 1L) \n        stop(\"'trim' must be numeric of length one\")\n    n <- length(x)\n    if (trim > 0 && n) {\n        if (is.complex(x)) \n            stop(\"trimmed means are not defined for complex data\")\n        if (anyNA(x)) \n            return(NA_real_)\n        if (trim >= 0.5) \n            return(stats::median(x, na.rm = FALSE))\n        lo <- floor(n * trim) + 1\n        hi <- n + 1 - lo\n        x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]\n    }\n    .Internal(mean(x))\n}\n<bytecode: 0x119711518>\n<environment: namespace:base>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DescTools)\nOddsRatio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, conf.level = NULL, ...) \n{\n    UseMethod(\"OddsRatio\")\n}\n<bytecode: 0x139b96810>\n<environment: namespace:DescTools>\n```\n:::\n\n```{.r .cell-code}\nmethods(OddsRatio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] OddsRatio.default*  OddsRatio.glm*      OddsRatio.multinom*\n[4] OddsRatio.zeroinfl*\nsee '?methods' for accessing help and source code\n```\n:::\n\n```{.r .cell-code}\nDescTools:::OddsRatio.default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, conf.level = NULL, y = NULL, method = c(\"wald\", \n    \"mle\", \"midp\"), interval = c(0, 1000), ...) \n{\n    if (!is.null(y)) \n        x <- table(x, y, ...)\n    if (is.null(conf.level)) \n        conf.level <- NA\n    p <- (d <- dim(x))[1L]\n    if (!is.numeric(x) || length(d) != 2L || p != d[2L] || p != \n        2L) \n        stop(\"'x' is not a 2x2 numeric matrix\")\n    switch(match.arg(arg = method, choices = c(\"wald\", \"mle\", \n        \"midp\")), wald = {\n        if (any(x == 0)) x <- x + 0.5\n        lx <- log(x)\n        or <- exp(lx[1, 1] + lx[2, 2] - lx[1, 2] - lx[2, 1])\n        if (is.na(conf.level)) {\n            res <- or\n        } else {\n            sigma2lor <- sum(1/x)\n            ci <- or * exp(c(1, -1) * qnorm((1 - conf.level)/2) * \n                sqrt(sigma2lor))\n            res <- c(`odds ratio` = or, lwr.ci = ci[1], upr.ci = ci[2])\n        }\n    }, mle = {\n        if (is.na(conf.level)) {\n            res <- unname(fisher.test(x, conf.int = FALSE)$estimate)\n        } else {\n            res <- fisher.test(x, conf.level = conf.level)\n            res <- c(res$estimate, lwr.ci = res$conf.int[1], \n                upr.ci = res$conf.int[2])\n        }\n    }, midp = {\n        a1 <- x[1, 1]\n        a0 <- x[1, 2]\n        b1 <- x[2, 1]\n        b0 <- x[2, 2]\n        or <- 1\n        mue <- function(a1, a0, b1, b0, or) {\n            mm <- matrix(c(a1, a0, b1, b0), 2, 2, byrow = TRUE)\n            fisher.test(mm, or = or, alternative = \"l\")$p - fisher.test(x = x, \n                or = or, alternative = \"g\")$p\n        }\n        midp <- function(a1, a0, b1, b0, or = 1) {\n            mm <- matrix(c(a1, a0, b1, b0), 2, 2, byrow = TRUE)\n            lteqtoa1 <- fisher.test(mm, or = or, alternative = \"l\")$p.val\n            gteqtoa1 <- fisher.test(mm, or = or, alternative = \"g\")$p.val\n            0.5 * (lteqtoa1 - gteqtoa1 + 1)\n        }\n        EST <- uniroot(function(or) {\n            mue(a1, a0, b1, b0, or)\n        }, interval = interval)$root\n        if (is.na(conf.level)) {\n            res <- EST\n        } else {\n            alpha <- 1 - conf.level\n            LCL <- uniroot(function(or) {\n                1 - midp(a1, a0, b1, b0, or) - alpha/2\n            }, interval = interval)$root\n            UCL <- 1/uniroot(function(or) {\n                midp(a1, a0, b1, b0, or = 1/or) - alpha/2\n            }, interval = interval)$root\n            res <- c(`odds ratio` = EST, lwr.ci = LCL, upr.ci = UCL)\n        }\n    })\n    return(res)\n}\n<bytecode: 0x11b986728>\n<environment: namespace:DescTools>\n```\n:::\n\n```{.r .cell-code}\ngetAnywhere(OddsRatio.default)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA single object matching 'OddsRatio.default' was found\nIt was found in the following places\n  registered S3 method for OddsRatio from namespace DescTools\n  namespace:DescTools\nwith value\n\nfunction (x, conf.level = NULL, y = NULL, method = c(\"wald\", \n    \"mle\", \"midp\"), interval = c(0, 1000), ...) \n{\n    if (!is.null(y)) \n        x <- table(x, y, ...)\n    if (is.null(conf.level)) \n        conf.level <- NA\n    p <- (d <- dim(x))[1L]\n    if (!is.numeric(x) || length(d) != 2L || p != d[2L] || p != \n        2L) \n        stop(\"'x' is not a 2x2 numeric matrix\")\n    switch(match.arg(arg = method, choices = c(\"wald\", \"mle\", \n        \"midp\")), wald = {\n        if (any(x == 0)) x <- x + 0.5\n        lx <- log(x)\n        or <- exp(lx[1, 1] + lx[2, 2] - lx[1, 2] - lx[2, 1])\n        if (is.na(conf.level)) {\n            res <- or\n        } else {\n            sigma2lor <- sum(1/x)\n            ci <- or * exp(c(1, -1) * qnorm((1 - conf.level)/2) * \n                sqrt(sigma2lor))\n            res <- c(`odds ratio` = or, lwr.ci = ci[1], upr.ci = ci[2])\n        }\n    }, mle = {\n        if (is.na(conf.level)) {\n            res <- unname(fisher.test(x, conf.int = FALSE)$estimate)\n        } else {\n            res <- fisher.test(x, conf.level = conf.level)\n            res <- c(res$estimate, lwr.ci = res$conf.int[1], \n                upr.ci = res$conf.int[2])\n        }\n    }, midp = {\n        a1 <- x[1, 1]\n        a0 <- x[1, 2]\n        b1 <- x[2, 1]\n        b0 <- x[2, 2]\n        or <- 1\n        mue <- function(a1, a0, b1, b0, or) {\n            mm <- matrix(c(a1, a0, b1, b0), 2, 2, byrow = TRUE)\n            fisher.test(mm, or = or, alternative = \"l\")$p - fisher.test(x = x, \n                or = or, alternative = \"g\")$p\n        }\n        midp <- function(a1, a0, b1, b0, or = 1) {\n            mm <- matrix(c(a1, a0, b1, b0), 2, 2, byrow = TRUE)\n            lteqtoa1 <- fisher.test(mm, or = or, alternative = \"l\")$p.val\n            gteqtoa1 <- fisher.test(mm, or = or, alternative = \"g\")$p.val\n            0.5 * (lteqtoa1 - gteqtoa1 + 1)\n        }\n        EST <- uniroot(function(or) {\n            mue(a1, a0, b1, b0, or)\n        }, interval = interval)$root\n        if (is.na(conf.level)) {\n            res <- EST\n        } else {\n            alpha <- 1 - conf.level\n            LCL <- uniroot(function(or) {\n                1 - midp(a1, a0, b1, b0, or) - alpha/2\n            }, interval = interval)$root\n            UCL <- 1/uniroot(function(or) {\n                midp(a1, a0, b1, b0, or = 1/or) - alpha/2\n            }, interval = interval)$root\n            res <- c(`odds ratio` = EST, lwr.ci = LCL, upr.ci = UCL)\n        }\n    })\n    return(res)\n}\n<bytecode: 0x11b986728>\n<environment: namespace:DescTools>\n```\n:::\n:::\n\n\n\n## unname\n\nCramer's Vを`chisq.test()`の結果を利用して作成する．\nその際，`unname()`によってカイ2乗統計量の名前をとる．\n\n\n::: {.cell}\n\n```{.r .cell-code}\noccupationalStatus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      destination\norigin   1   2   3   4   5   6   7   8\n     1  50  19  26   8   7  11   6   2\n     2  16  40  34  18  11  20   8   3\n     3  12  35  65  66  35  88  23  21\n     4  11  20  58 110  40 183  64  32\n     5   2   8  12  23  25  46  28  12\n     6  12  28 102 162  90 554 230 177\n     7   0   6  19  40  21 158 143  71\n     8   0   3  14  32  15 126  91 106\n```\n:::\n\n```{.r .cell-code}\nchisq.test(occupationalStatus)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in chisq.test(occupationalStatus): Chi-squared approximation may be\nincorrect\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tPearson's Chi-squared test\n\ndata:  occupationalStatus\nX-squared = 1416, df = 49, p-value < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nX2 <- chisq.test(occupationalStatus)$statistic |> unname()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in chisq.test(occupationalStatus): Chi-squared approximation may be\nincorrect\n```\n:::\n\n```{.r .cell-code}\nX2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1416.04\n```\n:::\n\n```{.r .cell-code}\nmy_CramerV <- sqrt(X2/min(dim(occupationalStatus)-1)/sum(occupationalStatus))\nmy_CramerV\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2404799\n```\n:::\n\n```{.r .cell-code}\nDescTools::CramerV(occupationalStatus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2404799\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}